## 1、七层计算机网络结构（OSI）  
答：
物理层：在局部局域网上传送数据桢，它负责管理计算机管理通讯设备和网络媒体之间的互通。包括了针脚、电压、线缆电压、集线器、中继器、网卡、主机接口等。  
数据链路层：负责网络寻址、错误侦测和改错。当表头和表尾被加之数据包时会形成桢。数据链表头（DLH）是包含了物理地址和错误侦测和改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）。  
网络层：决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据，例如：互联网协议（IP）等。  
传输层：把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息，例如：传输控制协议（TCP）等。  
会话层：负责在数据传输中设置和维护计算机网络中两台计算机之间的通讯连接。  
表示层：将数据转化为能与接收者的系统格式兼容并适合传输的格式。  
应用层：提供为应用软件而设的接口，以设置与另一软件之间的通信。例如：HTTP、HTTPS、FTP、TELNET、POP3、SMTP、SSH等。  

OSI 模型是一个标准而非实现，TCP/IP 四层模型由 OSI 7 层模型简化而来，是一个应用的具体实现。

## 2、TCP/IP 四层模型。  
答：  
应用层：HTTP、HTTPS、FTP、TELNET、POP3、SMTP、SSH  
传输层：TCP、UDP  
网络层：IP、ARP  
数据链路层  

![avatar](/pict/1.png)



## 3、简要描述三次握手四次挥手。  
答：三次握手：
  刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后
  
      1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。
      2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
      3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
      4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。
   四次挥手：
   刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：

      1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。

      2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。

      3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。

      4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态

      5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

![avatar](/pict/2.png)



## 4、ISN是固定的吗？  
答：三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。  
如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

## 5、什么是半连接队列？  
答：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。


## 6、为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭？  
答：要确保服务器是否已经收到了我们的 ACK 包，如果没有收到的话，服务器会重新发 FIN 包给客户端，客户端再次收到 ACK 包之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。

## 7、HTTP 1.x版本缺点。  
答：- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。  
- HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。  
- http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

## 8、HTTP 2.0特点。  
答：二进制分帧。这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。  
头部压缩。HTTP 1.1版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。  
多路复用。复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。  
服务器推送。允许服务器未经请求，主动向客户端发送资源，即服务器推送。请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

## 9、HTTP状态码。  
答：
 HTTP 的状态码为「三位数」，第一个数字定义了响应的类别，被分为五类:  
「1xx」: 代表请求已被接受，需要继续处理。  
「2xx」: 表示成功状态。  
「3xx」: 重定向状态。  
「4xx」: 客户端错误。  
「5xx」: 服务器端错误。  

301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。  
302 found，临时性重定向，表示资源临时被分配了新的 URL。  
303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。  
304 not modified，当协商缓存命中时会返回这个状态码。  
307 temporary redirect，临时重定向，和302含义相同,不会改变method  

400 bad request，请求报文存在语法错误。  
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。  
403 forbidden，表示对请求资源的访问被服务器拒绝。  
404 not found，表示在服务器上没有找到请求的资源。  
405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法。

500 internal sever error，表示服务器端在执行请求时发生了错误。  
502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。  
503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。  


## 10、DNS 为什么使用 UDP 协议作为传输层协议？  
答：「DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。」

为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

## 11、HTTP有哪些请求方法？
答：  
HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法  
HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT
http/1.1规定了以下请求方法(注意，都是大写):  
GET：请求获取Request-URI所标识的资源  
POST：在Request-URI所标识的资源后附加新的数据  
HEAD：请求获取由Request-URI所标识的资源的响应消息报头  
PUT：请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）  
DELETE：请求服务器删除对应所标识的资源  
TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断  
CONNECT：建立连接隧道，用于代理服务器  
OPTIONS：列出可对资源实行的请求方法，用来跨域请求  

## 12、什么是CDN加速？
答：
由于静态网站的请求资源是不会经常发生变化的，那么这种资源其实很容易被迁移，我们都知道网络传输的效率是和距离长短有关系的，既然静态资源很容易被迁移那么我们就可以把静态资源服务器按地域分布在多个服务节点上，当用户请求网站时候根据一个路由算法将请求落地在离用户最近的节点上，这样就可以减少网络传输的距离从而提升访问的效率，这就是我们长提的大名鼎鼎的CDN技术，内容分发网络技术。

  CDN技术应该由三个步骤组成，首先是解析DNS，找到离用户最近的CDN服务器，接下来CDN要做一下负载均衡，根据负载均衡策略将请求落地到最合适的一个服务器上，如果CDN服务器上就有用户所需要的静态资源，那么这个资源就会直接返回给浏览器，如果没有CDN服务器会请求远端的服务器，拉取资源再把资源返回给浏览器，如此同时拉取的资源也被缓存在CDN服务器上，下次访问就不需要在请求远端的服务器了，CDN存储资源的方式使用的是缓存，这个缓存的载体是和apache，nginx类似的服务器，我们一般称之为http加速器，之所以成为http加速器是为了和传统静态web服务器区别开来，传统的静态资源服务器一般都是从持久化设备上读取文件，而http加速器则是从内存里读取，不过具体存储的计算模型会根据硬件特点做优化使得资源读取的效率更高，常见的http加速器有varnish，squid。Ngnix加上缓存模块也是可以当做http加速器使用的，不管使用什么技术CDN的服务器基本都是做一个就近的缓存操作
  
## 13、GET和POST的区别？
答：
本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。

具体差别👇

从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。  
从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。  
从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。  
GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。  
GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。  
从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。


## 14、什么是url编码？
答：  
URL 只能使用 ASCII 字符集来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。URL 编码使用 "%" 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。


## 15、TCP队头阻塞与HTTP队头阻塞一样吗？
答：
TCP队头阻塞：TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。
HTTP队头阻塞：http队头阻塞和TCP队头阻塞完全不是一回事。
http1.x采用长连接(Connection:keep-alive)，可以在一个TCP请求上，发送多个http请求。
有非管道化和管道化，两种方式。
非管道化，完全串行执行，请求->响应->请求->响应...，后一个请求必须在前一个响应之后发送。
管道化，请求可以并行发出，但是响应必须串行返回。后一个响应必须在前一个响应之后。原因是，没有序号标明顺序，只能串行接收。
管道化请求的致命弱点:
1. 会造成队头阻塞，前一个响应未及时返回，后面的响应被阻塞
2. 请求必须是幂等请求，不能修改资源。因为，意外中断时候，客户端需要把未收到响应的请求重发，非幂等请求，会造成资源破坏。
由于这个原因，目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式。
无论是非管道化还是管道化，都会造成队头阻塞(请求阻塞)。




## 15、HTTP队头阻塞解决办法？
答：
1. 并发TCP连接（浏览器一个域名采用6-8个TCP连接，并发HTTP请求）
2. 域名分片（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）
2. HTTP2方式

http2使用一个域名单一TCP连接发送请求，请求包被二进制分帧，不同请求可以互相穿插，避免了http层面的请求队头阻塞。
但是不能避免TCP层面的队头阻塞。



## 16、HTTPS与HTTP的区别？
答：
HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。
那么区别有哪些呢：

HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。  
HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。  
HTTPS标准端口443，HTTP标准端口80。  
HTTPS需要用到SSL证书，而HTTP不用。  
我觉得记住以下两点HTTPS主要作用就行：

对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;对网站服务器进行真实身份认证。


## 17、说说HTTPS的工作原理？
答：
- HTTPS就是使用SSL/TLS协议进行加密传输大致流程：
- 客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个「对称加密的秘钥」，使用「该公钥」加密，传输给服务端，服务端再通过解密拿到该「对称秘钥」，后续的所有信息都通过该「对称秘钥」进行加密解密，完成整个HTTPS的流程。
- 「第三方认证」，最重要的是「数字签名」，避免了获取的公钥是中间人的。

![avatar](/pict/3.png)


## 18、TCP四次挥手最后一次ack如果客户端没收到怎么办？
答：
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

## 19、为什么连接的时候是三次握手，关闭的时候却是四次握手？
答：
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

## 20、为什么不能用两次握手进行连接？
答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，
也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。  

这主要是为了防止已失效的请求连接报文忽然又传送到了，从而产生错误。
假定A向B发送一个连接请求，由于一些原因，导致A发出的连接请求在一个网络节点逗留了比较多的时间。
此时A会将此连接请求作为无效处理 又重新向B发起了一次新的连接请求，B正常收到此连接请求后建立了连接，
数据传输完成后释放了连接。
如果此时A发出的第一次请求又到达了B，B会以为A又发起了一次连接请求，如果是两次握手：此时连接就建立了，
B会一直等待A发送数据，从而白白浪费B的资源。 
如果是三次握手：由于A没有发起连接请求，也就不会理会B的连接响应，B没有收到A的确认连接，就会关闭掉本次连接。

## 21、如果已经建立了连接，但是客户端突然出现故障了怎么办？
答：
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，
服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## 22、SSL连接断开后如何恢复？
答：一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。

## 23、短轮询、长轮询和 WebSocket 间的区别？
答：
短轮询：  

浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行
响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。
优缺点。

优点是比较简单，易于理解。
缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。

长轮询：    

首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将
这个请求挂起，然后判断服务器端数据是否有更新。
如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。

优缺点：

长轮询和短轮询比起来，它的优点是「明显减少了很多不必要的 http 请求次数」，相比之下节约了资源。
长轮询的缺点在于，连接挂起也会导致资源的浪费。

WebSocket：  

WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。



## 23、正向代理与反向代理的区别？
答：
正向代理：  
我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。
反向代理：  
这种代理模式下，它隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现负载平衡。

## 24、从输入URL到页面呈现发生了什么？
答：
1、构建请求；  
首先，浏览器构建「请求行」信息，构建好后，浏览器准备发起网络请求；  
2、查找缓存；  
在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。
先检查强缓存，如果命中的话直接使用，否则进入下一步；
3、DNS解析；  
4、建立TCP链接；  
通过「三次握手」建立客户端和服务器之间的连接。
进行数据传输。
断开连接的阶段。数据传输完成，现在要断开连接了，通过「四次挥手」来断开连接。
5、发送HTTP请求；  
发送HTTP请求的话，需要携带三样东西：「请求行」，「请求头」，「请求体」。  
6、网络响应；  
HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是通常我们说的返回网络响应。
跟请求部分类似，网络响应具有三个部分:「响应行」、「响应头」和「响应体」。  
7、渲染阶段；  
1）构建DOM树
2）样式计算
3）布局阶段
4）分层
5）绘制
6）分块
7）光栅化
8）合成

## 25、什么是跨域？
答：
跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。  
同源策略是一个安全策略。所谓的同源,指的是协议,域名,端口相同。

## 26、什么是CORS？
答：
CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。  
它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。  
CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。  
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。
